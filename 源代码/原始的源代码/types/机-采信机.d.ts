/**
 * ═══════════════════════════════════════════════════════════════════════════════
 *           范之集： 【采信机】
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/** */

import type {
    范_采信机系统_其This之默认式,
} from './共'







declare module '@wulechuan/controller-of-form' {

    /**
     * 关于为各函数绑定 this 的做法。
     *
     * 外界可以（借助【采信机】的工厂函数）向【采信机】明确给出
     * 一个作为 this 的对象。
     *
     * 如果本工具集用于某采用 Vuejs 框架的研发项目中，此举恐怕有所裨益。
     *
     * 以 `采信机.应对.某事件处理程序` 为例，
     * 如果外界传入该事件处理程序时没有另行、先行绑定 this ，
     * 则本工具会在幕后将自动为 `采信机.应对.某事件处理程序` 绑定给定的 this 。
     *
     * ────────────────────────────────
     *
     * 在编码设计过程中，我遇到一种问题：
     *
     * TypeScript 在作类型检查时，会“固执”的认为
     * 调用 `某事件处理程序` 时的 this 理应为 `采信机.应对`，
     * 哪怕采用了 `& ThisType<范_某特定This>` 这一写法也无济于事。
     *
     * 为迁就 TypeScript 的类型检查机制，
     * 不得不令【完备式】的 `应对` 中的各【方法函数】“假装”不会绑定任何 this 。
     * 此举实际上是“欺骗” TypeScript 的类型检查机。
     * 同时，令【形参准用式】的 `诸事件之应对` 中的各【方法函数】配有绑定的 this 。
     *
     * 另一做法我也尝试过，可行，但最终放弃。
     *
     * 该被放弃之做法如下：
     *
     * 在定义诸【范】时，不少【范】同时具备【完备式】、【形参准用式】两种变体。
     * 并且两种变体中的各【方法函数】均配有绑定 this 。
     * 又，在本工具集内部调用某【方法函数】时，总是明确采用 `.call(this)` 的形式。
     *
     * 放弃上述方案的原因是，已知 Vuejs 会绑死 this 的情况下，仍在调用时采用 `call` 方式，
     * 令我觉得多此一举，我不喜欢这样做。
     */



    /** */

    export type 范_采信机_形制要求总集_形参准用式<
        范_该采信机_其This = 范_采信机系统_其This之默认式
    > = {
    };



    export type 范_采信机<
        范_该采信机_其This = 范_采信机系统_其This之默认式
    > = {
    };





    export declare function 作一采信机 <
        范_该采信机_其This
    >(
        this: 范_该采信机_其This,

        该采信机之形制要求总集?:
            范_采信机_形制要求总集_形参准用式<
                范_该采信机_其This
            >
    ): (
        null | 范_采信机<范_该采信机_其This>
    );

}
